package parseJson

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"strings"
)

type AutoGenerated struct {
	ID             int                 `json:"id"`
	Image          string              `json:"image,omitempty"`
	Name           string              `json:"name"`
	Members        []string            `json:"members"`
	CreationDate   int                 `json:"creationDate"`
	FirstAlbum     string              `json:"firstAlbum"`
	Locations      string              `json:"locations"`
	ConcertDates   string              `json:"concertDates"`
	DatesLocations map[string][]string `json:"datesLocations"`
	Cities         []string
}

type All struct {
	AllArtists   []AutoGenerated
	FoundArtists []AutoGenerated
}

type Locations struct {
	ID        int      `json:"id"`
	Locations []string `json:"locations"`
	Dates     string   `json:"dates"`
}

type Locations2 struct {
	Index []struct {
		ID        int      `json:"id"`
		Locations []string `json:"locations"`
		Dates     string   `json:"dates"`
	} `json:"index"`
}

func GetLocations(num int) (Locations, int) {
	var locations Locations
	id := strconv.Itoa(num)

	path := fmt.Sprintf("https://groupietrackers.herokuapp.com/api/locations/%v", id)

	resp, err := http.Get(path)
	if err != nil {
		return locations, http.StatusInternalServerError
	}
	defer resp.Body.Close()

	json.NewDecoder(resp.Body).Decode(&locations)

	return locations, http.StatusOK
}

var LocationsRes Locations2

func GetLocations2() int {
	path := "https://groupietrackers.herokuapp.com/api/locations"

	resp, err := http.Get(path)
	if err != nil {
		return http.StatusInternalServerError
	}
	defer resp.Body.Close()

	json.NewDecoder(resp.Body).Decode(&LocationsRes)

	return http.StatusOK
}

var Artists []AutoGenerated

// Decodes the Json body from the response
func GetArtists(url string) ([]AutoGenerated, int) {
	resp, err := http.Get(url)
	if err != nil {
		return Artists, http.StatusInternalServerError
	}
	defer resp.Body.Close()

	if err = json.NewDecoder(resp.Body).Decode(&Artists); err != nil {
		fmt.Println("error")
		log.Printf("error with decoding : %v\n", err)
	}

	status := GetLocations2()
	if status != http.StatusOK {
		return Artists, status
	}

	for i := range Artists {
		Artists[i].Cities = LocationsRes.Index[i].Locations
	}

	return Artists, http.StatusOK
}

// The function checks the artist ID
func CheckId(url string) (int, int) {
	var id int

	artists, err := GetArtists(url)
	if err != http.StatusOK {
		return id, http.StatusInternalServerError
	}

	for i := 0; i < len(artists); i++ {
		id = artists[len(artists)-1].ID
	}

	return id, http.StatusOK
}

// Decodes the Json body from the response
func GetArtist(w http.ResponseWriter, r *http.Request) (AutoGenerated, Locations, int) {
	var artists AutoGenerated
	var locations Locations

	checkID, statusErr := CheckId("https://groupietrackers.herokuapp.com/api/artists")
	if statusErr != http.StatusOK {
		return artists, locations, http.StatusInternalServerError
	}

	id, err := strconv.Atoi(strings.TrimPrefix(r.URL.Path, "/pageTwo/"))
	if err != nil || id == 0 {
		return artists, locations, http.StatusNotFound
	}

	if checkID < id {
		return artists, locations, http.StatusNotFound
	}

	path := fmt.Sprintf("https://groupietrackers.herokuapp.com/api/artists/%v", id)

	resp, err := http.Get(path)
	if err != nil {
		return artists, locations, http.StatusInternalServerError
	}
	defer resp.Body.Close()

	json.NewDecoder(resp.Body).Decode(&artists)

	path2 := fmt.Sprintf("https://groupietrackers.herokuapp.com/api/relation/%v", id)

	resp2, err := http.Get(path2)
	if err != nil {
		return artists, locations, http.StatusInternalServerError
	}

	defer resp.Body.Close()

	json.NewDecoder(resp2.Body).Decode(&artists)

	locations, statusErr = GetLocations(id)
	if statusErr != http.StatusOK {
		return artists, locations, http.StatusInternalServerError
	}

	return artists, locations, http.StatusOK
}
